import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.file.Files;
import java.nio.file.LinkOption;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;

/**
 * <h1>SearchLog</h1>
 * The SearchLog program implements an application that
 * Reads the data from a log file from the directory, initialize the application and 
 * Query the CPU usage of a server for a time range. To exit press "EXIT" or "exit".
 * <p>
 * 
 * @author Akshat Misra
 * @version 1.0
 * @since   2016-04-25 
 */

public class SearchLog {

	HashMap<String, String> hmap = new HashMap<String, String>();
	static ArrayList<String> ipaddr = new ArrayList<String>();
	static long epoch = 0;
	static long maxepoch = 0;

	/**
	 * The main application is initiated and it creates the instance of SearchLog class.
	 * The SearchLog initialize method is called.
	 * @param args 1 argument required directory location. 
	 * if more arguments are passed, program will exit with "Arguments not valid" message.
	 * if no argument is passed, program will exit with "Please provide the Directory path" message.
	 */
	public static void main(String args[]) {
		SearchLog sl = new SearchLog();

		if (args.length >1)
		{
			System.out.println("Arguments not valid");
			System.exit(-1);
		}
		
		if(args.length == 0)
		{
			System.out.println("Please provide the Directory path");
			System.exit(-1);
		}
		
		try {
			sl.initialize(args[0]);
		} catch (FileNotFoundException e) {
			System.out.println("log file not available in the path mentioned");
			System.exit(-1);
		}

		Scanner sc = new Scanner(System.in);
		String terminate = "exit";
		String command;
		do {
			System.out.println("Enter Query: ");
			command = sc.nextLine();
			if (!command.toLowerCase().equals(terminate))
				sl.findEntry(command);
			else
				System.out.println("bye...");
		} while (!command.toLowerCase().equals(terminate));
		sc.close();
	}

	/**
	 * Parse data from the log file and store in memory
	 * @param path
	 * @exception FileNotFoundException
	 * @exception IOException
	 * @see FileNotFoundException
	 * @see IOException
	 */
	private void initialize(String path) throws FileNotFoundException {
		System.out.println("Initializing Search Log ");
		// validate the path is directory exist or not
		Path p = Paths.get(path);

		// method should not follow symbolic links in the file system to
		// determine if the path exists.
		if (!Files.exists(p, new LinkOption[] { LinkOption.NOFOLLOW_LINKS })) {
			throw new FileNotFoundException();
		}
		File f = new File(path + "/log.txt");
		if (!f.exists()) {
			throw new FileNotFoundException();
		}

		// Read line from the log file and initialize the hash map
		FileInputStream fis = new FileInputStream(f);
		BufferedReader br = new BufferedReader(new InputStreamReader(fis));

		try {
			String line = br.readLine();
			String [] initTime = line.split(" ");
			initEpoch(initTime[0].substring(0, 10).trim()); 
			do {
				String[] data = line.split(" ");
				if (data.length == 4) {
					initializeMap(data[0].substring(0, 10).trim(), data[1].trim(), data[2].trim(), data[3].trim());
					initializeIP(data[1].trim());
					valiateLogTime(data[0].trim());
				} else {
					System.out.println("The data in log file is curroupt");
					System.out.println("Initialization failed...");
					System.out.println("Exiting...");
					System.exit(-1);
				}
			} while ((line = br.readLine()) != null);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			// e.printStackTrace();
			System.out.println("Unable to read file content");
		}
		finally
		{
			try {
				br.close();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		System.out.println("Initialization Complete..");
	}

	/**
	 * Method to initialize the epoch and maxepoch for a day
	 * @param ep
	 */
	private void initEpoch(String ep) {
		
		epoch = Long.valueOf(ep);// considering that the log is generated by the Any Application
		maxepoch = epoch + 86340; // diff between the epoch of 1 day is 86340 sec
	}

	/**
	 * If the time in log file is not in range between epoch and maxepoch and the log file contains 
	 * information of more than 1 day
	 * @param ts timestamp
	 */
	private void valiateLogTime(String ts) {
		// TODO Auto-generated method stub
		Long time = Long.valueOf(ts);
		if(time>=epoch && time<=maxepoch)
			return;
		else
		{
			System.out.println("Log contains data for more than 1 day");
			System.out.println("Log file is corrupt... Cannot proceed...");
			System.out.println("Exiting Application ...");
			System.exit(-1);
		}
	}

	/**
	 * Read the IP address from the log file and initialize the ipaddr for 1000 servers
	 * @param ipadd
	 */
	private void initializeIP(String ipadd) {
		// TODO Auto-generated method stub
		if (!ipaddr.contains(ipadd))
			ipaddr.add(ipadd);
		if(ipaddr.size() > 1000)
		{
			System.out.println("Log contains data for more than 1000 server");
			System.out.println("Log file is corrupt... Cannot proceed...");
			System.out.println("Exiting Application ...");
			System.exit(-1);
		}
	}

	/**
	 * Initialize the Hash map to store the log information
	 * @param time Epoch Timestamp stored in log file
	 * @param ip IP address of the server stored in the log file
	 * @param cpuId Cpu Id of the server stored in the log file
	 * @param usage Cpu Usage of the cpu stored in the log file
	 */
	private void initializeMap(String time, String ip, String cpuId, String usage) {
		StringBuilder key = new StringBuilder();
		key.append(time + ",");
		key.append(ip + ",");
		key.append(String.valueOf(cpuId));

		StringBuilder value = new StringBuilder();
		value.append(Validate.getDate(Long.parseLong(time)) + ",");
		value.append(String.valueOf(usage) + "%");

		this.enterData(key.toString(), value.toString());
	}

	/**
	 * Find the entry in Map
	 * @param command
	 */
	private void findEntry(String command) {
		boolean isValid = Validate.validateCommand(command);
		// QUERY IP cpu_id time_start time_end
		if (isValid) {
			String[] cmd = command.split(" ");
			if(cmd.length == 7)
			{
				String ip = cmd[1];
				int cpuId = Integer.parseInt(cmd[2].trim());
				String startTime = cmd[3] + " " + cmd[4];
				String endTime = cmd[5] + " " + cmd[6];
				searchData(ip, cpuId, startTime, endTime);
			}
		}

	}

	/**
	 * Search the key value in the hash map
	 * @param ip
	 * @param cpuId
	 * @param startTime
	 * @param endTime
	 */
	private void searchData(String ip, int cpuId, String startTime, String endTime) {
		ArrayList<String> cpuDetails = new ArrayList<String>();
		long start = getTime(startTime);
		long end = getTime(endTime);
		String startkey = getTime(startTime) + "," + ip + "," + String.valueOf(cpuId);
		while (start < end) {
			cpuDetails.add("( "+hmap.get(startkey)+" )");
			start = start + 60;
			startkey = start + "," + ip + "," + String.valueOf(cpuId);
		}
		System.out.println("CPU usage on " + ip);
		System.out.println(cpuDetails);
	}

	/**
	 * Get the epoch value from the yyyy-MM-dd HH:mm format
	 * @param time
	 * @return Long value epoch time.
	 */
	private long getTime(String time) {
		long t = 0;
		SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm");
		Date date;
		try {
			date = df.parse(time);
			t = date.getTime() / 1000;

		} catch (ParseException e) {
			e.printStackTrace();
		}
		return t;
	}

	/**
	 * Enter the Key Value pair in Hash Map
	 * @param key
	 * @param value
	 */
	private void enterData(String key, String value) {
		hmap.put(key, value);
	}

}
